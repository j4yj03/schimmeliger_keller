% !TEX root = ../Abschlussbericht_Schimmeliger_Keller.tex
%%
%%  Hochschule für Technik und Wirtschaft Berlin --  Projektabschlussbericht
%%
%% Kapitel 4 - Praktische Umsetzung
%%
%%

\chapter{Praktische Umsetzung} \label{Praktische Umsetzung}
\section{Verwendete Hardware} \label{Hardware}
\subsection{LoPy4-Development-Board} \label{LoPy4}

Das LoPy4 ist ein von Pycom Ltd. hergestelltes Development-Board für die Anwendungen im IoT-Bereich. Es unterstützt viele Schnittstellen und Übertragungsprotokolle, die für IoT-Anwendung von großer Relevanz sind. Die Abbildung \ref{fig:lopy-blockschaltbild} stellt die Funktionalitäten des LoPy4-Development-Boards in Form eines Blockdiagrammes  dar. 

\begin{figure}[h]
 \centering
 \includegraphics[width=1\textwidth]{pictures/blockdiagram_lopy}
 \caption[LoPy4-Blockdiagramm]{LoPy4-Blockdiagramm}\cite{Lopy2022}
 \label{fig:systemkonzept}
\end{figure}

Im Kern befindet sich ein Espressif ESP32 mit Xtensa dual-core-32-bit LX6 Mikroprozessor. Als Speicher verwendet es 520KB + 4MB RAM und einen externen 8MB Flash-Speicher, wohin auch der Code dann geladen wird. 
Zur Ein-/Ausgabe und der Steuerung von Sensoren und Aktoren, bietet das Board vielseitige Peripherien wie GPIO, ADC, DAC, SPI, I2C, UART und PWM an. 

Darüberhinaus verfügt das Entwicklungsboard über WLAN (802.11b/g/n/e/i), Bluetooth/Bluetooth Low Energy (BLE) v4.2, sowie LoRa und Sigfox Protokolle.  
Es lässt sich leicht mit einem Breadboard benutzen, um damit einfache Schaltungen, ohne zu löten, testen zu können. 

Für die WLAN und Bluetooth Anwendung kann man entweder die interne, im Board eingebaute, oder eine externe Antenne verwenden. Bei der Nutzung von LoRa und Sigfox muss man jedoch darauf achten, dass man unbedingt eine externe Antenne verwendet, denn sonst könnte damit der LoRa-Chip beschädigt und unbrauchbar gemacht werden. Dafür gibt es zwei Anschlussmöglichkeiten; einmal für das 868 MHz und einmal für das 433 MHz Frequenzband. 
<<<<<<< HEAD
=======

Dafür wird der SX1276 LoRa-Transceiver-Chip der Firma Semtech verwendet.

\subsection{Mögliche Schaltung zum Selbstbauen} \label{LoPy4}

\subsection{DHT Sensormodul} \label{DHT}

Bei dem verwendeten Sensor handelt es sich um einen sog. DHT Sensor. Diesen gibt es in zwei verschiedenen Ausführungen, DHT11 und DHT22, wobei sich diese im auswertbaren Messbereich, der Messgenauigkeit und im Preis unterscheiden.
>>>>>>> 18b6446251714704563d4d7d0640c6edc0f42753

Dafür wird der SX1276 LoRa-Transceiver-Chip der Firma Semtech verwendet. 

Für die Spannungsversorgung wird lediglich ein Mikro-USB-Kabel, welches an eine USB-Schnittstelle am Computer das Board mit 3.3-5.5V versorgt, benötigt. Neben der Spannungsversorgung kann damit auch das Board direkt programmiert werden. 

Für die Programmierung des Boards kann man auf unterschiedliche Entwicklungsumgebungen zurückgreifen. So werden die Entwicklungsumgebungen wie Atom und Visual Studio Code (VSC) von dem Hersteller mit einem sogenannten Pymakr-Plugin für einen reibungslosen Upload und das Flashen des Boards unterstützt. Wenn das Benutzen des Plugins nicht möglich ist, wie unter anderem es teilweise bei uns der Fall war, so kann man auf das von PyCom angebotene File-Transfer-Protocol (FTP) zugreifen. Dafür muss man zunächst einmal einen FTP-Server auf dem Board erzeugen, mithilfe dessen man dann auf das Filesystem des Boards Zugriff hat. Damit der Code im Board läuft, muss man lediglich die jeweiligen Dateien (hauptsächlich die main.py Datei) auf das Board mit FTP-Befehlen in den Flash-Speicher kopieren. 

Für die Unterstützung von LoRa bietet es zwei Möglichkeiten: LoRa-RAW und LoRaWAN. 

Mit LoRa-RAW kann eine direkte Punkt-zu-Punkt Verbindung für die Kommunikation zwischen zwei LoRa-Knoten hergestellt werden. Mit LoRaWAN kann darüberhinaus der LoRa-Knoten in das TheThingsNetwork (TTN) oder das Chirpstack-Netzwerk eingebunden werden. Die Bandbreite kann zwischen den Werten 125, 250 und 500 kHz variiert werden. Außerdem kann man den Spreizfaktor zwischen 7 und 12 auswählen. Für die Synchronisation kann die Preamble mit der Anzahl der Chirps angepasst werden, wobei der Standardwert bei acht liegt. Wieviele „Chips” ein Symbol definieren, kann man mit der Coderate einstellen.

Darüberhinaus ist zu erwähnen, dass PyCom mit PyMesh, auch die Möglichkeit eines LoRa-Mesh-Netzwerkes auf der MAC-Ebene anbietet. Es ist dabei wichtig, dass alle LoRa-Knoten das gleiche Frequenzband, Spreizfaktor und Bandbreite verwenden. Es verwendet dazu ein hierarchisches Mesh-Netzwerkmodell.


\subsection{DHT Sensormodul} \label{DHT}

\begin{center}
	\begin{figure}[h]
	 
	 \noindent\makebox[\textwidth]{\includegraphics[width=0.7\textwidth]{pictures/dht11_dataframe}}
	 \caption[DHT Paketstruktur]{DHT Paketstruktur}
	 \label{fig:zeitplanung}
	\end{figure}
\end{center}



\subsection{Restliche Hardware} \label{Restliche Hardware}




\section{Beschreibung der Software} \label{Software}

Für unser Projekt haben wir drei verschiedene, miteinander interagierende Software Komponenten realisiert, welche über eine Schnittstelle (Interface) miteinander kommunizieren. 
Der Vorteil einer solchen Architektur ist, dass die einzelnen Komponenten sich unter umständen wiederverwenden lassen und sich im Idealfall so eine Software modular aufbauen lässt.
Da wir als Programmiersprache ausschließlich Python bzw. Micropython verwendet haben, könnte man argumentieren, dass unsere Software automatisch Modular ist, da sich in der Theorie alle programmierten Komponenten in Python wiederverwenden lassen.
Dies ist aber sehr verallgemeinert gesprochen, da gerade die Programmierung der Mikrocontroller definitiv auch Individualsoftware benötigt, welche sich aber immerhin nicht nur auf einer einzelnen Mikrocontrollerfamilie ausführen funktionieren würde.
Anzumerken ist noch, dass für unsere finale Version des Projektes vermutlich nur eine einzelne Softwarekomponente notwendig wäre.


\subsection{1. Komponente: Sensoransteuerung und der Versand der Daten mittels LoRa(WAN)} \label{Sender}

Für die Programmierung der Mikrocontroller verwenden wir die Programmiersprache Micropython, welche eine schlanke und schnelle Implementation der Programmiersprache Python ist, welche für Mikrocontroller optimiert wurde.

\begin{center}
	\begin{figure}[h]
	 
	 \noindent\makebox[\textwidth]{\includegraphics[width=0.4\textwidth]{pictures/sens_read_lora_send}}
	 \caption[PAP komponente 1]{Programm Ablauf: Komponente 1}
	 \label{fig:zeitplanung}
	\end{figure}
\end{center}

<<<<<<< HEAD
\subsection{2. Komponente: Emfangen der Daten und Versand ins Internet} \label{Empfänger}

\ldots
=======
Zunächst wird der Microcontroller initialisiert, wobei er standartmäßig mit allen Modulen (WiFi, LoRa, etc.) im aktivierten Zustand startet. Dieser Umstand beruht darauf, dass wir die PyCom Plattform nutzen, welche wenig vorab Konfiguration ermöglicht.\\
Jegliche Konfigurationsmöglichkeiten unserer Programme haben wir in extern Dateien im JSON Format abgelegt, welche im nächsten Schritt eingelesen werden. In der Konfigurationsdatei können unter Anderem die Dauer, die der Microcontroller im Schlafmodus verbringen soll, sowie die einzelnen Sensoren definiert werden.\\
Um das anbinden mehrere Sensonren zu ermöglichen haben wir uns dazu entschieden, eine Klasse zu programmieren, welche eben dieses Sensorobjekt darstellen soll. Der Treiber wurde von einem Benutzer auf github veröffentlicht, funktioniert aber im Prinzip nach dem oben genannten Verfahren, was bedeutet, dass zunächst eine gewisse Zeit gewartet wird, anschließend das Bus auf GND Niveau gezogen wird, um den Sensor mitzuteilen, dass er doch bitte anfängt Messwerte zu sammeln. Nachdem der Sensor eine Antwort gegeben hat, werden die empfangenen Bits zunächst alle gesammelt und anschließend in 5 einzelne Bytepakete decodiert. Abschließend prüft der Treiber mithilfer der Prüfsumme, ob die empfangenen Daten Sinn machen.\\ Je nach Sensortyp (DHT11/22) werden die empfangenen Daten nochmals in den richtigen Wertebereich \grqq verschoben\grqq.\\
Anschließend werden für alle initialisierten Sensoren, über den Treiber die aktuellen Messwerte eingelesen und in ein bytearray verpackt, wobei hier schon das erste mal geschaut wird, ob die gemessen Sensorwerte überhaupt Sinn ergeben bzw. in dem vom Hersteller angebenen Bereich fallen, da es selbst bei der korrekten Dekodierung immernoch zu unsinnigen Werten kommen kann. 
Wurde dieser Test erfolgreich bestanden wird im Microcontroller über das LoRa Modul über eine Bibliothek initialisiert und die ermittelten Werte werden versendet.\\ Ein weiterer Bestandteil des bytearrays ist die aktuelle Systemzeit, welche verwendet wird, um im späteren Verlauf ermitteln zu können, ob es sich wirklich um ein neues empfangenes Datenpaket handelt, oder ob das Paket in irgendeinem Puffer zunächst verloren gegangen ist und zufällig wieder ins Tageslicht gerückt ist.\\
Zu guter Letzt wird der Microcontroller in den Schlafmodus versetzt, wobei die Zeit, die er im stromsparenden Modus verbringt benutzerdefiniert ist. Die Systemzeit läuft auch im Schlafmodus weiter, solange der Microcontroller mit Strom versorgt wird, nur das LoRa-Modul muss neu initialisiert werden.\\

\newpage

\subsection{2. Komponente: Emfangen der Daten und Versand ins Internet} \label{Empfänger}

\begin{center}
	\begin{figure}[h]
	 
	 \noindent\makebox[\textwidth]{\includegraphics[width=0.3\textwidth]{pictures/LoRaRead}}
	 \caption[PAP komponente 2]{Programm Ablauf: Komponente 2}
	 \label{fig:lorareadwifisend}
	\end{figure}
\end{center}

Diese Softwarekomponente läuft schlussendlich auf dem LoRa Gateway, bzw. in unserem Fall dem zweiten Microcontroller, welcher in unserem Fall den Empfänger bei der P2P Verbindung darstellt.
Wie bei der ersten Komponente, wird zunächst der Microcontroller initialisiert. Des Weiteren werden Konfigurationsdaten eingelesen, welche für die optionale WiFi Verbindung und das senden an die MQTT Broker benötigt werden. Möchte man die Sensordaten einfach nur über eine serielle Schnittstelle auslesen, können diese Felder entsprechend leer gelassen werden.
Außerdem wird in dieser Komponente das LoRa Modul direkt initialisiert, da dies nur einmalig geschehen muss.\\
Es beginnt eine Endlosschleife

\newpage
>>>>>>> 18b6446251714704563d4d7d0640c6edc0f42753

\subsection{3. Komponente: Manuelles abrufen und versenden der veröffentlichten Daten} \label{PubSub}

\ldots


\section{Visualisierung der Sensordaten} \label{Dashboard und Visualisierung}

\ldots


\section{Berechnung der Laufzeit im Batteriebetrieb} \label{Simulation}

\ldots
